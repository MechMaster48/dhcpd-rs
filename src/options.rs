use std::convert::TryInto;
///
///  dhcp message format by byte:
///  op (1 byte): 1 indicates a request, 2 a reply
///  htype (1 byte): ethernet is 1, 6 is IEEE 802 networks, 7 ARCNET. generally 6.
///  hlen (1): hardware address length. MAC address length; generally 6.
///  hops (1): generally 1. used by DHCP relays to go beyond subnet boundaries.
///  xid (4 bytes): transaction identifier. 32-bit identifier field generated by client, to match with replies from DHCP server.
///  secs (2): seconds elapsed since client began attempting to get an address. used by DHCP servers to prioritize responses.
///  flags (2): mostly unused flags area. subfield first bit is the Broadcast flag - client doesn't know its own IP yet, so respond by broadcast.
///  ciadrr (4): client puts is own address here. used only for RENEW, REBINDING, BOUND; otherwise 0. cuz it doesn't have one yet.
///  yiaddrr (4): 'your' ip address. take this, assign it to yourself. from dhcp server to client.
///  siaddr: (4): server ip address. usually the server's own.
///  giaddr (4): gateway ip (NOT DHCP DEFAULT GATEWAY. THAT'S ITS OWN DHCP OPTION.)
///  chwaddr (16): the client's mac address, used for making this a converation.
///  sname (64): server name.
///  file (128): boot filename.
///  options (variable): dhcp options, variable length.
///
#[derive(Default, Debug)]
pub(crate) struct DhcpMessage {
  op: u8,
  htype: u8,
  hlen: u8,
  hops: u8,
  xid: u32,
  secs: u16,
  flags: u16,
  ciaddr: u32,
  yiaddr: u32,
  siaddr: u32,
  giaddr: u32,
  chwaddr: u64,
  sname: u128,
  file: u128,
  options: Vec<u8>,
}

impl DhcpMessage {
  pub(crate) fn parse(&mut self, buf: &[u8]) {
    self.op = buf[0];
    self.htype = buf[1];
    self.hlen = buf[2];
    self.hops = buf[3];
    self.xid = u32::from_be_bytes(buf[4..8].try_into().unwrap());
    self.secs = u16::from_be_bytes(buf[9..11].try_into().unwrap());
    self.flags = u16::from_be_bytes(buf[11..13].try_into().unwrap());
    self.ciaddr = u32::from_be_bytes(buf[13..17].try_into().unwrap());
    self.yiaddr = u32::from_be_bytes(buf[17..21].try_into().unwrap());
    self.chwaddr = u64::from_be_bytes(buf[28..36].try_into().unwrap());
  }
}
